import { __extends } from "tslib";
/* eslint-disable @typescript-eslint/naming-convention */
import { Animation } from "@babylonjs/core/Animations/animation.js";
import { Quaternion, Vector3, Matrix } from "@babylonjs/core/Maths/math.vector.js";
import { Color3 } from "@babylonjs/core/Maths/math.color.js";
import { Material } from "@babylonjs/core/Materials/material.js";
var parseIntIndex = function (str) {
    var targetIndex = parseInt(str);
    if (isNaN(targetIndex)) {
        return -1;
    }
    return targetIndex;
};
var getGltfNode = function (gltf, index) {
    if (gltf.nodes) {
        var i = parseIntIndex(index);
        if (i != -1) {
            return gltf.nodes[i];
        }
    }
    return null;
};
var getGltfMaterial = function (gltf, index) {
    if (gltf.materials) {
        var i = parseIntIndex(index);
        if (i != -1) {
            return gltf.materials[i];
        }
    }
    return null;
};
var getGltfCamera = function (gltf, index) {
    if (gltf.cameras) {
        var i = parseIntIndex(index);
        if (i != -1) {
            return gltf.cameras[i];
        }
    }
    return null;
};
var getGltfExtension = function (gltf, index) {
    if (gltf.extensions && index) {
        return gltf.extensions[index];
    }
    return null;
};
var getMatrix = function (_target, source, offset, scale) {
    return scale ? Matrix.FromArray(source, offset).scale(scale) : Matrix.FromArray(source, offset);
};
var getVector3 = function (_target, source, offset, scale) {
    return scale ? Vector3.FromArray(source, offset).scaleInPlace(scale) : Vector3.FromArray(source, offset);
};
var getQuaternion = function (_target, source, offset, scale) {
    return scale ? Quaternion.FromArray(source, offset).scaleInPlace(scale) : Quaternion.FromArray(source, offset);
};
var getColor3 = function (_target, source, offset, scale) {
    return scale ? Color3.FromArray(source, offset).scale(scale) : Color3.FromArray(source, offset);
};
var getAlpha = function (_target, source, offset, scale) {
    return scale ? source[offset + 3] * scale : source[offset + 3];
};
var getFloat = function (_target, source, offset, scale) {
    return scale ? source[offset] * scale : source[offset];
};
var getMinusFloat = function (_target, source, offset, scale) {
    return -(scale ? source[offset] * scale : source[offset]);
};
var getNextFloat = function (_target, source, offset, scale) {
    return scale ? source[offset + 1] * scale : source[offset + 1];
};
var getFloatBy2 = function (_target, source, offset, scale) {
    return (scale ? source[offset] * scale : source[offset]) * 2;
};
var getWeights = function (target, source, offset, scale) {
    if (target._numMorphTargets) {
        var value = new Array(target._numMorphTargets);
        for (var i = 0; i < target._numMorphTargets; i++) {
            value[i] = scale ? source[offset++] * scale : source[offset++];
        }
        return value;
    }
    return null;
};
var AbstractAnimationPointerPropertyInfos = /** @class */ (function () {
    function AbstractAnimationPointerPropertyInfos(type, name, get) {
        this.type = type;
        this.name = name;
        this.get = get;
    }
    AbstractAnimationPointerPropertyInfos.prototype._buildAnimation = function (animatable, fps, keys, babylonAnimationGroup, animationTargetOverride) {
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        if (animatable || animationTargetOverride) {
            var animationName = "".concat(babylonAnimationGroup.name, "_channel").concat(babylonAnimationGroup.targetedAnimations.length, "_").concat(this.name);
            var babylonAnimation = new Animation(animationName, this.name, fps, this.type);
            babylonAnimation.setKeys(keys);
            if (animationTargetOverride != null && animationTargetOverride.animations != null) {
                animationTargetOverride.animations.push(babylonAnimation);
                babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animationTargetOverride);
            }
            else if (animatable) {
                animatable.animations = animatable.animations || Array(1);
                animatable.animations.push(babylonAnimation);
                babylonAnimationGroup.addTargetedAnimation(babylonAnimation, animatable);
            }
        }
    };
    AbstractAnimationPointerPropertyInfos.prototype.isValid = function (_target) {
        return true;
    };
    return AbstractAnimationPointerPropertyInfos;
}());
var TransformNodeAnimationPointerPropertyInfos = /** @class */ (function (_super) {
    __extends(TransformNodeAnimationPointerPropertyInfos, _super);
    function TransformNodeAnimationPointerPropertyInfos(type, name, get) {
        if (get === void 0) { get = getVector3; }
        return _super.call(this, type, name, get) || this;
    }
    TransformNodeAnimationPointerPropertyInfos.prototype.isValid = function (target) {
        return target._babylonTransformNode !== null && target._babylonTransformNode !== undefined;
    };
    TransformNodeAnimationPointerPropertyInfos.prototype.buildAnimations = function (target, fps, keys, group, animationTargetOverride) {
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        return this._buildAnimation(target._babylonTransformNode, fps, keys, group, animationTargetOverride);
    };
    return TransformNodeAnimationPointerPropertyInfos;
}(AbstractAnimationPointerPropertyInfos));
var CameraAnimationPointerPropertyInfos = /** @class */ (function (_super) {
    __extends(CameraAnimationPointerPropertyInfos, _super);
    function CameraAnimationPointerPropertyInfos(type, name, get) {
        if (get === void 0) { get = getFloat; }
        return _super.call(this, type, name, get) || this;
    }
    CameraAnimationPointerPropertyInfos.prototype.isValid = function (target) {
        return target._babylonCamera != null && target._babylonCamera !== undefined;
    };
    CameraAnimationPointerPropertyInfos.prototype.buildAnimations = function (target, fps, keys, group, animationTargetOverride) {
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        return this._buildAnimation(target._babylonCamera, fps, keys, group, animationTargetOverride);
    };
    return CameraAnimationPointerPropertyInfos;
}(AbstractAnimationPointerPropertyInfos));
var MaterialAnimationPointerPropertyInfos = /** @class */ (function (_super) {
    __extends(MaterialAnimationPointerPropertyInfos, _super);
    function MaterialAnimationPointerPropertyInfos(type, name, get, fillMode) {
        if (get === void 0) { get = getFloat; }
        if (fillMode === void 0) { fillMode = Material.TriangleFillMode; }
        var _this = _super.call(this, type, name, get) || this;
        _this.fillMode = fillMode;
        return _this;
    }
    MaterialAnimationPointerPropertyInfos.prototype.isValid = function (target) {
        var data = target._data;
        if (data) {
            var c = data[this.fillMode];
            if (c) {
                return c.babylonMaterial !== null && c.babylonMaterial !== undefined;
            }
        }
        return false;
    };
    MaterialAnimationPointerPropertyInfos.prototype.buildAnimations = function (target, fps, keys, group, animationTargetOverride) {
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        return this._buildAnimation(target._data[this.fillMode].babylonMaterial, fps, keys, group, animationTargetOverride);
    };
    return MaterialAnimationPointerPropertyInfos;
}(AbstractAnimationPointerPropertyInfos));
var LightAnimationPointerPropertyInfos = /** @class */ (function (_super) {
    __extends(LightAnimationPointerPropertyInfos, _super);
    function LightAnimationPointerPropertyInfos(type, name, get) {
        if (get === void 0) { get = getFloat; }
        return _super.call(this, type, name, get) || this;
    }
    LightAnimationPointerPropertyInfos.prototype.isValid = function (target) {
        return target && target.length != 0;
    };
    // note : the extensions array store directly the BabylonLight reference
    LightAnimationPointerPropertyInfos.prototype.buildAnimations = function (target, fps, keys, group, animationTargetOverride, params) {
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        var i = parseIntIndex(params[1]);
        var l = i >= 0 && i < target.lights.length ? target.lights[i] : null;
        return this._buildAnimation(l._babylonLight, fps, keys, group, animationTargetOverride);
    };
    return LightAnimationPointerPropertyInfos;
}(AbstractAnimationPointerPropertyInfos));
var WeightAnimationPointerPropertyInfos = /** @class */ (function (_super) {
    __extends(WeightAnimationPointerPropertyInfos, _super);
    function WeightAnimationPointerPropertyInfos(type, name, get) {
        if (get === void 0) { get = getWeights; }
        return _super.call(this, type, name, get) || this;
    }
    WeightAnimationPointerPropertyInfos.prototype.isValid = function (target) {
        return target._numMorphTargets;
    };
    WeightAnimationPointerPropertyInfos.prototype.buildAnimations = function (targetNode, fps, keys, babylonAnimationGroup, _animationTargetOverride) {
        if (_animationTargetOverride === void 0) { _animationTargetOverride = null; }
        if (targetNode._numMorphTargets) {
            var _loop_1 = function (targetIndex) {
                var animationName = "".concat(babylonAnimationGroup.name, "_channel").concat(babylonAnimationGroup.targetedAnimations.length);
                var babylonAnimation = new Animation(animationName, this_1.name, fps, this_1.type);
                babylonAnimation.setKeys(keys.map(function (key) { return ({
                    frame: key.frame,
                    inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,
                    value: key.value[targetIndex],
                    outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,
                    interpolation: key.interpolation,
                }); }));
                if (targetNode._primitiveBabylonMeshes) {
                    for (var _i = 0, _a = targetNode._primitiveBabylonMeshes; _i < _a.length; _i++) {
                        var m = _a[_i];
                        var babylonMesh = m;
                        if (babylonMesh.morphTargetManager) {
                            var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);
                            var babylonAnimationClone = babylonAnimation.clone();
                            morphTarget.animations.push(babylonAnimationClone);
                            babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);
                        }
                    }
                }
            };
            var this_1 = this;
            for (var targetIndex = 0; targetIndex < targetNode._numMorphTargets; targetIndex++) {
                _loop_1(targetIndex);
            }
        }
    };
    return WeightAnimationPointerPropertyInfos;
}(AbstractAnimationPointerPropertyInfos));
var CoreAnimationNodesPointerMap = {
    getTarget: getGltfNode,
    hasIndex: true,
    matrix: {
        properties: [new TransformNodeAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_MATRIX, "matrix", getMatrix)],
    },
    translation: {
        properties: [new TransformNodeAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_VECTOR3, "position")],
    },
    rotation: {
        properties: [new TransformNodeAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", getQuaternion)],
    },
    scale: {
        properties: [new TransformNodeAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_VECTOR3, "scaling")],
    },
    weights: {
        getStride: function (target) {
            return target._numMorphTargets;
        },
        properties: [new WeightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "influence")],
    },
};
var CoreAnimationCamerasPointerMap = {
    hasIndex: true,
    getTarget: getGltfCamera,
    orthographic: {
        xmag: {
            properties: [
                new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat),
                new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat),
            ],
        },
        ymag: {
            properties: [
                new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat),
                new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat),
            ],
        },
        zfar: {
            properties: [new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "maxZ")],
        },
        znear: {
            properties: [new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "minZ")],
        },
    },
    perspective: {
        aspectRatio: {
        // not supported.
        },
        yfov: {
            properties: [new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "fov")],
        },
        zfar: {
            properties: [new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "maxZ")],
        },
        znear: {
            properties: [new CameraAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "minZ")],
        },
    },
};
var CoreAnimationMaterialsPointerMap = {
    hasIndex: true,
    getTarget: getGltfMaterial,
    pbrMetallicRoughness: {
        baseColorFactor: {
            properties: [
                new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3),
                new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha),
            ],
        },
        metallicFactor: {
            properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "metallic")],
        },
        roughnessFactor: {
            properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "roughness")],
        },
        baseColorTexture: {
            extensions: {
                KHR_texture_transform: {
                    scale: {
                        properties: [
                            // MAY introduce set scale(Vector2) into texture.
                            new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "albedoTexture.uScale"),
                            new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "albedoTexture.vScale", getNextFloat),
                        ],
                    },
                    offset: {
                        properties: [
                            // MAY introduce set offset(Vector2) into texture.
                            new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "albedoTexture.uOffset"),
                            new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "albedoTexture.vOffset", getNextFloat),
                        ],
                    },
                    rotation: {
                        properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "albedoTexture.wAng", getMinusFloat)],
                    },
                },
            },
        },
    },
    emissiveFactor: {
        properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3)],
    },
    normalTexture: {
        scale: {
            properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level")],
        },
    },
    occlusionTexture: {
        strength: {
            properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength")],
        },
        extensions: {
            KHR_texture_transform: {
                scale: {
                    properties: [
                        // MAY introduce set scale(Vector2) into texture.
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTexture.uScale"),
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTexture.vScale", getNextFloat),
                    ],
                },
                offset: {
                    properties: [
                        // MAY introduce set offset(Vector2) into texture.
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTexture.uOffset"),
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTexture.vOffset", getNextFloat),
                    ],
                },
                rotation: {
                    properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "ambientTexture.wAng", getMinusFloat)],
                },
            },
        },
    },
    emissiveTexture: {
        extensions: {
            KHR_texture_transform: {
                scale: {
                    properties: [
                        // MAY introduce set scale(Vector2) into texture.
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveTexture.uScale"),
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveTexture.vScale", getNextFloat),
                    ],
                },
                offset: {
                    properties: [
                        // MAY introduce set offset(Vector2) into texture.
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveTexture.uOffset"),
                        new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveTexture.vOffset", getNextFloat),
                    ],
                },
                rotation: {
                    properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveTexture.wAng", getMinusFloat)],
                },
            },
        },
    },
    extensions: {
        KHR_materials_ior: {
            ior: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction")],
            },
        },
        KHR_materials_clearcoat: {
            clearcoatFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity")],
            },
            clearcoatRoughnessFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness")],
            },
        },
        KHR_materials_sheen: {
            sheenColorFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3)],
            },
            sheenRoughnessFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness")],
            },
        },
        KHR_materials_specular: {
            specularFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor")],
            },
            specularColorFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3)],
            },
        },
        KHR_materials_emissive_strength: {
            emissiveStrength: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity")],
            },
        },
        KHR_materials_transmission: {
            transmissionFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity")],
            },
        },
        KHR_materials_volume: {
            attenuationColor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3)],
            },
            attenuationDistance: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance")],
            },
            thicknessFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness")],
            },
        },
        KHR_materials_iridescence: {
            iridescenceFactor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity")],
            },
            iridescenceIor: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction")],
            },
            iridescenceThicknessMinimum: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness")],
            },
            iridescenceThicknessMaximum: {
                properties: [new MaterialAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness")],
            },
        },
    },
};
var CoreAnimationExtensionsPointerMap = {
    getTarget: getGltfExtension,
    KHR_lights_punctual: {
        isIndex: true,
        lights: {
            hasIndex: true,
            color: {
                properties: [new LightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3)],
            },
            intensity: {
                properties: [new LightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "intensity")],
            },
            range: {
                properties: [new LightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "range")],
            },
            spot: {
                innerConeAngle: {
                    properties: [new LightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2)],
                },
                outerConeAngle: {
                    properties: [new LightAnimationPointerPropertyInfos(Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2)],
                },
            },
        },
    },
};
export var CoreAnimationPointerMap = {
    nodes: CoreAnimationNodesPointerMap,
    materials: CoreAnimationMaterialsPointerMap,
    cameras: CoreAnimationCamerasPointerMap,
    extensions: CoreAnimationExtensionsPointerMap,
};
//# sourceMappingURL=KHR_animation_pointer.map.js.map