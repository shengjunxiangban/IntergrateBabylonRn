import { ArrayItem, GLTFLoader } from "../glTFLoader.js";
import { AnimationGroup } from "@babylonjs/core/Animations/animationGroup.js";
import { AnimationKeyInterpolation } from "@babylonjs/core/Animations/animationKey.js";
import { CoreAnimationPointerMap } from "./KHR_animation_pointer.map.js";
import { getDataAccessorElementCount } from "../glTFUtilities.js";
var NAME = GLTFLoader._KHRAnimationPointerName;
/**
 * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
var KHR_animation_pointer = /** @class */ (function () {
    /**
     * @param loader
     * @hidden
     */
    function KHR_animation_pointer(loader) {
        /**
         * used to gently ignore invalid pointer. If false, invalid pointer will throw exception.
         */
        this.ignoreInvalidPointer = true;
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this._loader = loader;
    }
    Object.defineProperty(KHR_animation_pointer.prototype, "enabled", {
        /**
         * Defines whether this extension is enabled.
         */
        get: function () {
            return this._loader.isExtensionUsed(NAME);
        },
        enumerable: false,
        configurable: true
    });
    /** @hidden */
    KHR_animation_pointer.prototype.dispose = function () {
        this._loader = null;
    };
    /**
     * according to specification,
     * It is not allowed to animate a glTFid property, as it does change the structure of the glTF in general
     * It is not allowed to animate a name property in general.
     * @param property
     * @hidden
     */
    KHR_animation_pointer.prototype.accept = function (property) {
        return property != "name";
    };
    KHR_animation_pointer.prototype.loadAnimationAsync = function (context, animation) {
        // ensure an animation group is present.
        if (!animation._babylonAnimationGroup) {
            this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;
            var group = new AnimationGroup(animation.name || "animation".concat(animation.index), this._loader.babylonScene);
            group._parentContainer = this._loader._assetContainer;
            this._loader.babylonScene._blockEntityCollection = false;
            animation._babylonAnimationGroup = group;
        }
        var babylonAnimationGroup = animation._babylonAnimationGroup;
        var promises = new Array();
        ArrayItem.Assign(animation.channels);
        ArrayItem.Assign(animation.samplers);
        for (var _i = 0, _a = animation.channels; _i < _a.length; _i++) {
            var channel = _a[_i];
            promises.push(this._loadAnimationChannelAsync("".concat(context, "/channels/").concat(channel.index), context, animation, channel));
        }
        return Promise.all(promises).then(function () {
            babylonAnimationGroup.normalize(0);
            return babylonAnimationGroup;
        });
    };
    /**
     * @hidden Loads a glTF animation channel.
     * @param context The context when loading the asset
     * @param animationContext The context of the animation when loading the asset
     * @param animation The glTF animation property
     * @param channel The glTF animation channel property
     * @param animationTargetOverride The babylon animation channel target override property. My be null.
     * @returns A void promise when the channel load is complete
     */
    KHR_animation_pointer.prototype._loadAnimationChannelAsync = function (context, animationContext, animation, channel, animationTargetOverride) {
        var _this = this;
        var _a, _b;
        if (animationTargetOverride === void 0) { animationTargetOverride = null; }
        if (channel.target.path != "pointer" /* POINTER */) {
            throw new Error("".concat(context, "/target/path: Invalid value (").concat(channel.target.path, ")"));
        }
        if (channel.target.node != undefined) {
            // According to KHR_animation_pointer specification
            // If this extension is used, the animation.channel.target.node must not be set.
            // Because the node is defined, the channel is ignored and not animated due to the specification.
            return Promise.resolve();
        }
        var pointer = (_b = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer) === null || _b === void 0 ? void 0 : _b.pointer;
        if (!pointer) {
            throw new Error("".concat(context, "/target/extensions/").concat(this.name, ": Pointer is missing"));
        }
        var sampler = ArrayItem.Get("".concat(context, "/sampler"), animation.samplers, channel.sampler);
        return this._loadAnimationSamplerAsync("".concat(context, "/samplers/").concat(channel.sampler), sampler).then(function (data) {
            var _a;
            // this is where we process the pointer.
            var animationTarget = _this._parseAnimationPointer("".concat(context, "/extensions/").concat(_this.name, "/pointer"), pointer);
            if (!animationTarget) {
                return;
            }
            // build the keys
            // build the animations into the group
            var babylonAnimationGroup = animation._babylonAnimationGroup;
            if (!babylonAnimationGroup) {
                return;
            }
            var outputAccessor = ArrayItem.Get("".concat(context, "/output"), _this._loader.gltf.accessors, sampler.output);
            // stride is the size of each element stored into the output buffer.
            var stride = (_a = animationTarget.stride) !== null && _a !== void 0 ? _a : getDataAccessorElementCount(outputAccessor.type);
            var fps = _this._loader.parent.targetFps;
            // we extract the corresponding values from the read value.
            // the reason for that is one GLTF value may be dispatched to several Babylon properties
            // one of example is baseColorFactor which is a Color4 under GLTF and dispatched to
            // - albedoColor as Color3(Color4.r,Color4.g,Color4.b)
            // - alpha as Color4.a
            for (var _i = 0, _b = animationTarget.properties; _i < _b.length; _i++) {
                var propertyInfo = _b[_i];
                // Ignore animations that have no animation valid targets.
                if (!propertyInfo.isValid(animationTarget.target)) {
                    return;
                }
                // build the keys.
                var keys = new Array(data.input.length);
                var outputOffset = 0;
                switch (data.interpolation) {
                    case "STEP" /* STEP */: {
                        for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {
                            keys[frameIndex] = {
                                frame: data.input[frameIndex] * fps,
                                value: propertyInfo.get(animationTarget.target, data.output, outputOffset),
                                interpolation: AnimationKeyInterpolation.STEP,
                            };
                            outputOffset += stride;
                        }
                        break;
                    }
                    case "CUBICSPLINE" /* CUBICSPLINE */: {
                        var invfps = 1 / fps;
                        for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {
                            var k = {
                                frame: data.input[frameIndex] * fps,
                            };
                            (k.inTangent = propertyInfo.get(animationTarget.target, data.output, outputOffset, invfps)), (outputOffset += stride);
                            (k.value = propertyInfo.get(animationTarget.target, data.output, outputOffset)), (outputOffset += stride);
                            (k.outTangent = propertyInfo.get(animationTarget.target, data.output, outputOffset, invfps)), (outputOffset += stride);
                            keys[frameIndex] = k;
                        }
                        break;
                    }
                    case "LINEAR" /* LINEAR */:
                    default: {
                        for (var frameIndex = 0; frameIndex < data.input.length; frameIndex++) {
                            keys[frameIndex] = {
                                frame: data.input[frameIndex] * fps,
                                value: propertyInfo.get(animationTarget.target, data.output, outputOffset),
                            };
                            outputOffset += stride;
                        }
                        break;
                    }
                }
                // each properties has its own build animation process.
                // these logics are located into KHR_animation_pointer.map.ts
                propertyInfo.buildAnimations(animationTarget.target, fps, keys, babylonAnimationGroup, animationTargetOverride, animationTarget.params);
            }
        });
    };
    KHR_animation_pointer.prototype._loadAnimationSamplerAsync = function (context, sampler) {
        if (sampler._data) {
            return sampler._data;
        }
        var interpolation = sampler.interpolation || "LINEAR" /* LINEAR */;
        switch (interpolation) {
            case "STEP" /* STEP */:
            case "LINEAR" /* LINEAR */:
            case "CUBICSPLINE" /* CUBICSPLINE */: {
                break;
            }
            default: {
                throw new Error("".concat(context, "/interpolation: Invalid value (").concat(sampler.interpolation, ")"));
            }
        }
        var inputAccessor = ArrayItem.Get("".concat(context, "/input"), this._loader.gltf.accessors, sampler.input);
        var outputAccessor = ArrayItem.Get("".concat(context, "/output"), this._loader.gltf.accessors, sampler.output);
        sampler._data = Promise.all([
            this._loader._loadFloatAccessorAsync("/accessors/".concat(inputAccessor.index), inputAccessor),
            this._loader._loadFloatAccessorAsync("/accessors/".concat(outputAccessor.index), outputAccessor),
        ]).then(function (_a) {
            var inputData = _a[0], outputData = _a[1];
            return {
                input: inputData,
                interpolation: interpolation,
                output: outputData,
            };
        });
        return sampler._data;
    };
    /**
     * parsing animation pointer is the core of animation channel.
     * Animation pointer is a Json pointer, which mean it locate an item into the json hierarchy.
     * Consequentely the pointer has the following BNF
   
     * <animationPointer> := <sep><assetContainer><sep><assetIndex><sep><propertyPath>
     * <assetContainer> := "nodes" | "materials" | "meshes" | "cameras" | "extensions"
     * <assetIndex> := <digit> | <name>
     * <propertyPath> := <extensionPath> | <standardPath>
     * <extensionPath> := "extensions"<sep><name><sep><standardPath>
     * <standardPath> := <name> | <name><sep><standardPath>
     * <sep>:= "/"
     * <name> := W+
     * <digit> := D+
     *
     * examples of pointer are
     *  - "/nodes/0/rotation"
     *  - "/materials/2/emissiveFactor"
     *  - "/materials/2/pbrMetallicRoughness/baseColorFactor"
     *  - "/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength"
     * @param context
     * @param pointer
     * @return
     */
    KHR_animation_pointer.prototype._parseAnimationPointer = function (context, pointer) {
        var sep = "/";
        if (pointer.charAt(0) == sep) {
            pointer = pointer.substring(1);
        }
        var parts = pointer.split(sep);
        // we have a least 3 part
        if (parts.length >= 3) {
            var node = CoreAnimationPointerMap; // the map of possible path
            var indices = [];
            var getTarget = null;
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                node = node[part];
                if (!node) {
                    // nothing to do so far
                    break;
                }
                if (node.getTarget) {
                    getTarget = node.getTarget;
                }
                if (node.hasIndex) {
                    indices.push(parts[++i]);
                    // move to the next part
                    continue;
                }
                if (node.isIndex) {
                    indices.push(part);
                    // move to the next part
                    continue;
                }
                if (node.properties && getTarget) {
                    var t = getTarget(this._loader.gltf, indices[0]);
                    if (t != null) {
                        return {
                            target: t,
                            stride: node.getStride ? node.getStride(t) : undefined,
                            properties: node.properties,
                            params: indices,
                        };
                    }
                }
            }
        }
        if (this.ignoreInvalidPointer) {
            return null;
        }
        throw new Error("".concat(context, " invalid pointer. ").concat(pointer));
    };
    return KHR_animation_pointer;
}());
export { KHR_animation_pointer };
GLTFLoader.RegisterExtension(NAME, function (loader) { return new KHR_animation_pointer(loader); });
//# sourceMappingURL=KHR_animation_pointer.js.map