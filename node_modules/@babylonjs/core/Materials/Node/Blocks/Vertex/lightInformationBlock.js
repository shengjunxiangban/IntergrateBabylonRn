import { __extends } from "tslib";
import { NodeMaterialBlock } from "../../nodeMaterialBlock.js";
import { NodeMaterialBlockConnectionPointTypes } from "../../Enums/nodeMaterialBlockConnectionPointTypes.js";
import { NodeMaterialBlockTargets } from "../../Enums/nodeMaterialBlockTargets.js";
import { RegisterClass } from "../../../../Misc/typeStore.js";
import { PointLight } from "../../../../Lights/pointLight.js";
/**
 * Block used to get data information from a light
 */
var LightInformationBlock = /** @class */ (function (_super) {
    __extends(LightInformationBlock, _super);
    /**
     * Creates a new LightInformationBlock
     * @param name defines the block name
     */
    function LightInformationBlock(name) {
        var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;
        _this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
        _this.registerOutput("direction", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerOutput("color", NodeMaterialBlockConnectionPointTypes.Color3);
        _this.registerOutput("intensity", NodeMaterialBlockConnectionPointTypes.Float);
        _this.registerOutput("shadowBias", NodeMaterialBlockConnectionPointTypes.Float);
        _this.registerOutput("shadowNormalBias", NodeMaterialBlockConnectionPointTypes.Float);
        _this.registerOutput("shadowDepthScale", NodeMaterialBlockConnectionPointTypes.Float);
        _this.registerOutput("shadowDepthRange", NodeMaterialBlockConnectionPointTypes.Vector2);
        return _this;
    }
    /**
     * Gets the current class name
     * @returns the class name
     */
    LightInformationBlock.prototype.getClassName = function () {
        return "LightInformationBlock";
    };
    Object.defineProperty(LightInformationBlock.prototype, "worldPosition", {
        /**
         * Gets the world position input component
         */
        get: function () {
            return this._inputs[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "direction", {
        /**
         * Gets the direction output component
         */
        get: function () {
            return this._outputs[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "color", {
        /**
         * Gets the direction output component
         */
        get: function () {
            return this._outputs[1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "intensity", {
        /**
         * Gets the direction output component
         */
        get: function () {
            return this._outputs[2];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "shadowBias", {
        /**
         * Gets the shadow bias output component
         */
        get: function () {
            return this._outputs[3];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "shadowNormalBias", {
        /**
         * Gets the shadow normal bias output component
         */
        get: function () {
            return this._outputs[4];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "shadowDepthScale", {
        /**
         * Gets the shadow depth scale component
         */
        get: function () {
            return this._outputs[5];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightInformationBlock.prototype, "shadowDepthRange", {
        /**
         * Gets the shadow depth range component
         */
        get: function () {
            return this._outputs[6];
        },
        enumerable: false,
        configurable: true
    });
    LightInformationBlock.prototype.bind = function (effect, nodeMaterial, mesh) {
        if (!mesh) {
            return;
        }
        if (this.light && this.light.isDisposed()) {
            this.light = null;
        }
        var light = this.light;
        var scene = nodeMaterial.getScene();
        if (!light && scene.lights.length) {
            light = this.light = scene.lights[0];
            this._forcePrepareDefines = true;
        }
        if (!light || !light.isEnabled) {
            effect.setFloat3(this._lightDataUniformName, 0, 0, 0);
            effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);
            return;
        }
        light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);
        effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);
        var generator = light.getShadowGenerator();
        if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {
            if (generator) {
                effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);
            }
            else {
                effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);
            }
        }
        if (this.shadowDepthRange) {
            if (generator && scene.activeCamera) {
                var shadowLight = light;
                effect.setFloat2(this._lightShadowExtraUniformName, shadowLight.getDepthMinZ(scene.activeCamera), shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera));
            }
            else {
                effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);
            }
        }
    };
    LightInformationBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {
        if (!defines._areLightsDirty && !this._forcePrepareDefines) {
            return;
        }
        this._forcePrepareDefines = false;
        var light = this.light;
        defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);
    };
    LightInformationBlock.prototype._buildBlock = function (state) {
        _super.prototype._buildBlock.call(this, state);
        state.sharedData.bindableBlocks.push(this);
        state.sharedData.blocksWithDefines.push(this);
        var direction = this.direction;
        var color = this.color;
        var intensity = this.intensity;
        var shadowBias = this.shadowBias;
        var shadowNormalBias = this.shadowNormalBias;
        var shadowDepthScale = this.shadowDepthScale;
        var shadowDepthRange = this.shadowDepthRange;
        this._lightDataUniformName = state._getFreeVariableName("lightData");
        this._lightColorUniformName = state._getFreeVariableName("lightColor");
        this._lightShadowUniformName = state._getFreeVariableName("shadowData");
        this._lightShadowExtraUniformName = state._getFreeVariableName("shadowExtraData");
        this._lightTypeDefineName = state._getFreeDefineName("LIGHTPOINTTYPE");
        state._emitUniformFromString(this._lightDataUniformName, "vec3");
        state._emitUniformFromString(this._lightColorUniformName, "vec4");
        state.compilationString += "#ifdef ".concat(this._lightTypeDefineName, "\r\n");
        state.compilationString += this._declareOutput(direction, state) + " = normalize(".concat(this.worldPosition.associatedVariableName, ".xyz - ").concat(this._lightDataUniformName, ");\r\n");
        state.compilationString += "#else\r\n";
        state.compilationString += this._declareOutput(direction, state) + " = ".concat(this._lightDataUniformName, ";\r\n");
        state.compilationString += "#endif\r\n";
        state.compilationString += this._declareOutput(color, state) + " = ".concat(this._lightColorUniformName, ".rgb;\r\n");
        state.compilationString += this._declareOutput(intensity, state) + " = ".concat(this._lightColorUniformName, ".a;\r\n");
        if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {
            state._emitUniformFromString(this._lightShadowUniformName, "vec3");
            if (shadowBias.hasEndpoints) {
                state.compilationString += this._declareOutput(shadowBias, state) + " = ".concat(this._lightShadowUniformName, ".x;\r\n");
            }
            if (shadowNormalBias.hasEndpoints) {
                state.compilationString += this._declareOutput(shadowNormalBias, state) + " = ".concat(this._lightShadowUniformName, ".y;\r\n");
            }
            if (shadowDepthScale.hasEndpoints) {
                state.compilationString += this._declareOutput(shadowDepthScale, state) + " = ".concat(this._lightShadowUniformName, ".z;\r\n");
            }
        }
        if (shadowDepthRange.hasEndpoints) {
            state._emitUniformFromString(this._lightShadowExtraUniformName, "vec2");
            state.compilationString += this._declareOutput(shadowDepthRange, state) + " = ".concat(this._lightShadowUniformName, ";\r\n");
        }
        return this;
    };
    LightInformationBlock.prototype.serialize = function () {
        var serializationObject = _super.prototype.serialize.call(this);
        if (this.light) {
            serializationObject.lightId = this.light.id;
        }
        return serializationObject;
    };
    LightInformationBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {
        _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
        if (serializationObject.lightId) {
            this.light = scene.getLightById(serializationObject.lightId);
        }
    };
    return LightInformationBlock;
}(NodeMaterialBlock));
export { LightInformationBlock };
RegisterClass("BABYLON.LightInformationBlock", LightInformationBlock);
//# sourceMappingURL=lightInformationBlock.js.map